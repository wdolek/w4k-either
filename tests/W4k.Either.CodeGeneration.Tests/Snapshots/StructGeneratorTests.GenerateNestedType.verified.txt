// <auto-generated />

#nullable enable

namespace MyLittleEither.MyLittleEitherMonad
{
    public partial class MyContainingType
    {
        private partial struct MyNestedEither<TLeft, TRight>
        {
            private readonly byte _idx;
            private readonly TLeft? _v1;
            private readonly TRight? _v2;

            public MyNestedEither(TLeft? value)
            {
                _idx = 1;
                _v1 = value;
                _v2 = default;
            }

            public MyNestedEither(TRight? value)
            {
                _idx = 2;
                _v1 = default;
                _v2 = value;
            }

            [global::System.Diagnostics.Contracts.Pure]
            public object? Case
            {
                get
                {
                    switch (_idx)
                    {
                        case 1:
                            return _v1;
                        case 2:
                            return _v2;
                        default:
                            return ThrowHelper.ThrowOnInvalidState<object?>();
                    }
                }
            }

            [global::System.Diagnostics.Contracts.Pure]
            public static bool operator ==(MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> left, MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> right) => left.Equals(right);

            [global::System.Diagnostics.Contracts.Pure]
            public static bool operator !=(MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> left, MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> right) => !(left == right);

            [global::System.Diagnostics.Contracts.Pure]
            public static implicit operator MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight>(TLeft? value) => new(value);

            [global::System.Diagnostics.Contracts.Pure]
            public static implicit operator MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight>(TRight? value) => new(value);

            [global::System.Diagnostics.Contracts.Pure]
            public override int GetHashCode()
            {
                switch (_idx)
                {
                    case 1:
                        return _v1?.GetHashCode() ?? 0;
                    case 2:
                        return _v2?.GetHashCode() ?? 0;
                    default:
                        return ThrowHelper.ThrowOnInvalidState<int>();
                }
            }

            [global::System.Diagnostics.Contracts.Pure]
            public override string ToString()
            {
                switch (_idx)
                {
                    case 1:
                        return _v1?.ToString() ?? string.Empty;
                    case 2:
                        return _v2?.ToString() ?? string.Empty;
                    default:
                        return ThrowHelper.ThrowOnInvalidState<string>();
                }
            }

            [global::System.Diagnostics.Contracts.Pure]
            public override bool Equals(object? obj)
            {
                if (obj is not MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> other)
                {
                    return false;
                }

                return Equals(other);
            }

            [global::System.Diagnostics.Contracts.Pure]
            public bool Equals(MyLittleEither.MyLittleEitherMonad.MyContainingType.MyNestedEither<TLeft, TRight> other)
            {
                if (_idx != other._idx)
                {
                    return false;
                }

                switch (_idx)
                {
                    case 1:
                        return (_v1 is null && other._v1 is null) || (_v1?.Equals(other._v1) ?? false);
                    case 2:
                        return (_v2 is null && other._v2 is null) || (_v2?.Equals(other._v2) ?? false);
                    default:
                        return ThrowHelper.ThrowOnInvalidState<bool>();
                }
            }

            [global::System.Diagnostics.Contracts.Pure]
            public bool TryPick(out TLeft? value)
            {
                if (_idx == 1)
                {
                    value = _v1;
                    return true;
                }

                value = default;
                return false;
            }

            [global::System.Diagnostics.Contracts.Pure]
            public bool TryPick(out TRight? value)
            {
                if (_idx == 2)
                {
                    value = _v2;
                    return true;
                }

                value = default;
                return false;
            }

            public TResult Match<TResult>(
                global::System.Func<TLeft?, TResult> f1,
                global::System.Func<TRight?, TResult> f2)
            {
                global::System.ArgumentNullException.ThrowIfNull(f1);
                global::System.ArgumentNullException.ThrowIfNull(f2);

                switch(_idx)
                {
                    case 1:
                        return f1(_v1);
                    case 2:
                        return f2(_v2);
                    default:
                        return ThrowHelper.ThrowOnInvalidState<TResult>();
                }
            }

            public TResult Match<TState, TResult>(
                TState state,
                global::System.Func<TState, TLeft?, TResult> f1,
                global::System.Func<TState, TRight?, TResult> f2)
            {
                global::System.ArgumentNullException.ThrowIfNull(f1);
                global::System.ArgumentNullException.ThrowIfNull(f2);

                switch(_idx)
                {
                    case 1:
                        return f1(state, _v1);
                    case 2:
                        return f2(state, _v2);
                    default:
                        return ThrowHelper.ThrowOnInvalidState<TResult>();
                }
            }

            public global::System.Threading.Tasks.Task<TResult> MatchAsync<TResult>(
                global::System.Func<TLeft?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> f1,
                global::System.Func<TRight?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> f2,
                global::System.Threading.CancellationToken cancellationToken = default)
            {
                global::System.ArgumentNullException.ThrowIfNull(f1);
                global::System.ArgumentNullException.ThrowIfNull(f2);

                switch(_idx)
                {
                    case 1:
                        return f1(_v1, cancellationToken);
                    case 2:
                        return f2(_v2, cancellationToken);
                    default:
                        return ThrowHelper.ThrowOnInvalidState<global::System.Threading.Tasks.Task<TResult>>();
                }
            }

            public global::System.Threading.Tasks.Task<TResult> MatchAsync<TState, TResult>(
                TState state,
                global::System.Func<TState, TLeft?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> f1,
                global::System.Func<TState, TRight?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> f2,
                global::System.Threading.CancellationToken cancellationToken = default)
            {
                global::System.ArgumentNullException.ThrowIfNull(f1);
                global::System.ArgumentNullException.ThrowIfNull(f2);

                switch(_idx)
                {
                    case 1:
                        return f1(state, _v1, cancellationToken);
                    case 2:
                        return f2(state, _v2, cancellationToken);
                    default:
                        return ThrowHelper.ThrowOnInvalidState<global::System.Threading.Tasks.Task<TResult>>();
                }
            }

            public void Switch(
                global::System.Action<TLeft?> a1,
                global::System.Action<TRight?> a2)
            {
                Match(
                    v => { a1(v); return Unit.Default; },
                    v => { a2(v); return Unit.Default; });
            }

            public void Switch<TState>(
                TState state,
                global::System.Action<TState, TLeft?> a1,
                global::System.Action<TState, TRight?> a2)
            {
                Match(
                    state,
                    (s, v) => { a1(s, v); return Unit.Default; },
                    (s, v) => { a2(s, v); return Unit.Default; });
            }

            public global::System.Threading.Tasks.Task SwitchAsync(
                global::System.Func<TLeft?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> a1,
                global::System.Func<TRight?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> a2,
                global::System.Threading.CancellationToken cancellationToken = default)
            {
                return MatchAsync(
                    async (v, ct) => { await a1(v, ct); return Unit.Default; },
                    async (v, ct) => { await a2(v, ct); return Unit.Default; },
                    cancellationToken);
            }

            public global::System.Threading.Tasks.Task SwitchAsync<TState>(
                TState state,
                global::System.Func<TState, TLeft?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> a1,
                global::System.Func<TState, TRight?, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> a2,
                global::System.Threading.CancellationToken cancellationToken = default)
            {
                return MatchAsync(
                    state,
                    async (s, v, ct) => { await a1(s, v, ct); return Unit.Default; },
                    async (s, v, ct) => { await a2(s, v, ct); return Unit.Default; },
                    cancellationToken);
            }
        }
    }
}
