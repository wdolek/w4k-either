namespace W4k.Either.Generator;

internal sealed class CodeGenerator
{
    private readonly GeneratorContext _context;
    private readonly IMemberCodeGenerator[] _memberGenerators;

    public CodeGenerator(GeneratorContext context)
    {
        _context = context;
        _memberGenerators =
        [
            new FieldsGenerator(context),
            new ConstructorsGenerator(context),
            new SerializableGenerator(context),
            new PropertiesGenerator(context),
            new OperatorsGenerator(context),
            new ObjectOverridesGenerator(context),
            new EquatableGenerator(context),
            new TryPickGenerator(context),
            new BindGenerator(context),
            new MapGenerator(context),
            new MatchGenerator(context),
            new SwitchGenerator(context)
        ];
    }

    public void Generate(IndentedWriter writer)
    {
        GenerateFileHeader(writer);
        GenerateNamespace(writer);
    }

    private static void GenerateFileHeader(IndentedWriter writer)
    {
        writer.AppendIndentedLine("// <auto-generated />");
        writer.AppendLineBreak();
        writer.AppendIndentedLine("#nullable enable");
        writer.AppendLineBreak();
    }

    private void GenerateNamespace(IndentedWriter writer)
    {
        var ns = _context.TypeDeclaration.TargetNamespace;
        if (string.IsNullOrEmpty(ns))
        {
            GenerateContainingType(writer);
        }
        else
        {
            writer.AppendIndentedLine($"namespace {ns}");
            writer.AppendIndentedLine("{");

            GenerateContainingType(writer.Indent());

            writer.AppendIndentedLine("}");
        }
    }

    private void GenerateContainingType(IndentedWriter writer)
    {
        // generating top-level type
        if (_context.ContainingTypeDeclaration is null)
        {
            GenerateType(writer);
            return;
        }

        // generating nested type
        writer.AppendIndentedLine(_context.ContainingTypeDeclaration.FullDeclaration);
        writer.AppendIndentedLine("{");

        GenerateType(writer.Indent());

        writer.AppendIndentedLine("}");
    }

    private void GenerateType(IndentedWriter writer)
    {
        writer.AppendIndentedLine(_context.TypeDeclaration.FullDeclaration);
        writer.AppendIndentedLine("{");

        var indentedWriter = writer.Indent();
        foreach (var generator in _memberGenerators)
        {
            if (generator.CanGenerate())
            {
                generator.Generate(indentedWriter);
            }
        }

        // generators may leave empty line at the end
        writer.RemoveLastLineBreak();

        writer.AppendIndentedLine("}");
    }
}